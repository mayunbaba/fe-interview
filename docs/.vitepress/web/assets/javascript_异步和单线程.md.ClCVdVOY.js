import{_ as i,i as r,j as n,D as _,L as h,P as p,a1 as s}from"./chunks/framework.DyWNUh6Q.js";import"./chunks/theme.0vZazFZp.js";const u={methods:{addDom:m}};function m(){console.log("点击了添加dom按钮");const a=document.querySelector(".btn");a.innerHTML="添加dom按钮 "+new Date().toLocaleString();const e=document.createElement("p");e.innerHTML="我是新添加的dom "+new Date().toLocaleString(),document.querySelector(".button-wrap").appendChild(e)}const b={class:"button-wrap"};function S(a,e,t,c,d,o){return r(),n("div",b,[_("button",{onClick:e[0]||(e[0]=l=>o.addDom()),class:"btn button-s"},"添加dom按钮")])}const f=i(u,[["render",S]]),q="/assets/image-1.DvlYj_Ci.png",P={components:{render:f}},k=JSON.parse('{"title":"异步","description":"","frontmatter":{},"headers":[],"relativePath":"javascript/异步和单线程.md","filePath":"javascript/异步和单线程.md"}'),v=s('<h1 id="异步" tabindex="-1">异步 <a class="header-anchor" href="#异步" aria-label="Permalink to &quot;异步&quot;">​</a></h1><p><img src="'+q+'" alt="alt text"></p><h2 id="浏览器如何渲染网页" tabindex="-1">浏览器如何渲染网页 <a class="header-anchor" href="#浏览器如何渲染网页" aria-label="Permalink to &quot;浏览器如何渲染网页&quot;">​</a></h2><h3 id="浏览器主要进程" tabindex="-1">浏览器主要进程 <a class="header-anchor" href="#浏览器主要进程" aria-label="Permalink to &quot;浏览器主要进程&quot;">​</a></h3><ul><li>浏览器进程：主要负责界面显示、用户交互、子进程管理。浏览器进城内部会启动多个线程处理不同的任务。</li><li>网络进程：负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</li><li><strong>渲染进程</strong>：渲染进程启动后，会开启一个渲染主线程，主线程负责执行HTML、CSS、JS代码。 <ul><li>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。</li></ul></li></ul><h3 id="渲染主线程是如何工作的" tabindex="-1">渲染主线程是如何工作的 <a class="header-anchor" href="#渲染主线程是如何工作的" aria-label="Permalink to &quot;渲染主线程是如何工作的&quot;">​</a></h3><ul><li>解析HTML</li><li>解析CSS</li><li>计算样式</li><li>按帧率绘制图层</li><li>执行全局JS代码</li><li>执行事件处理函数</li><li>执行计时器的回调函数</li></ul><p><strong>案例</strong></p>',8),T=s('<h3 id="如何理解js的异步" tabindex="-1">如何理解JS的异步 <a class="header-anchor" href="#如何理解js的异步" aria-label="Permalink to &quot;如何理解JS的异步&quot;">​</a></h3><p>渲染主线程承担着渲染页面、解析执行JS的任务。遇到比较耗时的操作，比如定时器、网络请求、事件监听，交给WebAPI处理。当WebAPI处理完成后，将事件包装成任务，放入任务队列。等待主线程调度。</p><h2 id="异步编程的原理" tabindex="-1">异步编程的原理 <a class="header-anchor" href="#异步编程的原理" aria-label="Permalink to &quot;异步编程的原理&quot;">​</a></h2><ol><li>JavaScript 引擎是单线程的，一次只能执行一个任务。</li><li>异步任务（如定时器、事件监听、网络请求等）不会阻塞主线程的执行，而是会在后台执行。</li><li>当异步任务完成时，会将回调函数放入任务队列（Callback Queue）中。</li><li>主线程执行完当前任务后，会从任务队列中取出一个回调函数执行。</li><li>这个过程是循环的，即事件循环（Event Loop），使得 JavaScript 能够处理异步操作。</li></ol><h2 id="异步编程的实现方式" tabindex="-1">异步编程的实现方式 <a class="header-anchor" href="#异步编程的实现方式" aria-label="Permalink to &quot;异步编程的实现方式&quot;">​</a></h2><ul><li>回调函数</li><li>Promise 链式调用</li><li>async （语法糖，如果await返回一个promise，函数将会等待promise对象转换为resolve后继续向下执行）</li></ul><h2 id="event-loop-机制和dom渲染" tabindex="-1">event loop 机制和DOM渲染 <a class="header-anchor" href="#event-loop-机制和dom渲染" aria-label="Permalink to &quot;event loop 机制和DOM渲染&quot;">​</a></h2><p>js是单线程的，而且和DOM渲染共用一个线程 js执行的时候，得留一些时机供DOM渲染</p><h2 id="宏任务和微任务" tabindex="-1">宏任务和微任务 <a class="header-anchor" href="#宏任务和微任务" aria-label="Permalink to &quot;宏任务和微任务&quot;">​</a></h2><p>宏任务：setTimeout、setInterval、Ajax、DOM事件</p><p>微任务：Promise、async/await</p><p>微任务执行比宏任务早 微任务--&gt;DOM渲染--&gt;宏任务</p>',12);function x(a,e,t,c,d,o){const l=h("render");return r(),n("div",null,[v,p(l),T])}const C=i(P,[["render",x]]);export{k as __pageData,C as default};
