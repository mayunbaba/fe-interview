import{_ as c,i as u,j as h,D as e,p as l,E as _,F as y,L as i,P as p,a1 as v}from"./chunks/framework.DyWNUh6Q.js";import"./chunks/theme.0vZazFZp.js";const g={name:"lifeCycle",props:{num:{type:Number,default:0}},inject:["provideNum","add"],data(){return{role:"child"}},beforeCreate(){console.log("beforeCreate",this.role,"child")},created(){console.log("created",this.role)},beforeMount(){console.log("beforeMount",this.role)},mounted(){console.log("mounted",this.role)},beforeUpdate(){console.log("beforeUpdate",this.role)},updated(){console.log("updated",this.role)},beforeDestroy(){console.log("beforeDestroy",this.role)},destroyed(){console.log("destroyed",this.role)}},m=o=>(_("data-v-991dde9a"),o=o(),y(),o),k={class:"child-container","data-title":"我是子组件"},C=m(()=>e("h5",null,"props传入的数据是响应式的，不建议修改父组件数据",-1)),$=m(()=>e("h5",null,"子组件修改父组件数据：",-1)),D=m(()=>e("h5",null,"provide注入的数据不是响应式的，一般用来调用父组件方法",-1));function q(o,t,s,f,a,n){return u(),h("div",k,[e("div",null,[C,e("span",null,"props："+l(s.num),1)]),e("div",null,[$,e("button",{class:"button-s",onClick:t[0]||(t[0]=r=>o.$emit("update:num",100))},"v-model配合$emit。sync vue3已废弃"),e("button",{class:"button-s danger",onClick:t[1]||(t[1]=r=>o.$parent.num++)},"$parent 不建议（造成代码无法维护）")]),e("div",null,[D,e("span",null,"provide："+l(n.provideNum),1),e("button",{class:"button-s",onClick:t[2]||(t[2]=(...r)=>n.add&&n.add(...r))},"父组件注入的add方法，相当于调用父组件方法")])])}const w=c(g,[["render",q],["__scopeId","data-v-991dde9a"]]),x={name:"lifeCycle",components:{child:w},provide(){return{provideNum:this.provideNum,add:this.add}},data(){return{role:"father",num:0,provideNum:0}},beforeCreate(){console.log("beforeCreate",this.role,"father")},created(){console.log("created",this.role)},beforeMount(){console.log("beforeMount",this.role)},mounted(){console.log("mounted",this.role)},beforeUpdate(){console.log("beforeUpdate",this.role)},updated(){console.log("updated",this.role)},beforeDestroy(){console.log("beforeDestroy",this.role)},destroyed(){console.log("destroyed",this.role)},methods:{add(){this.num++,this.provideNum++,console.log(this.num,"num")}}},M={class:"container","data-title":"我是父组件"};function P(o,t,s,f,a,n){const r=i("child");return u(),h("div",M,[e("div",null,"props: "+l(a.num),1),e("div",null," provide: "+l(a.provideNum),1),e("button",{class:"button-s",onClick:t[0]||(t[0]=(...d)=>n.add&&n.add(...d))},"+"),p(r,{num:a.num,"onUpdate:num":t[1]||(t[1]=d=>a.num=d)},null,8,["num"])])}const V=c(x,[["render",P],["__scopeId","data-v-8f0f1ccc"]]),N={data(){return{message:"Hello, Vue!"}},watch:{message:{immediate:!0,handler(o,t){console.log("watcher执行了")}}},created(){console.log("created执行了")}};function U(o,t,s,f,a,n){return u(),h("div",null,[e("p",null,l(a.message),1)])}const S=c(N,[["render",U]]),T={components:{lifeCycle:V,watchC:S}},E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue/index.md","filePath":"vue/index.md"}'),I=v(`<h2 id="vue生命周期" tabindex="-1">vue生命周期 <a class="header-anchor" href="#vue生命周期" aria-label="Permalink to &quot;vue生命周期&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>创建阶段</span></span>
<span class="line"><span>beforeCreated</span></span>
<span class="line"><span>created（setup）</span></span>
<span class="line"><span>挂载阶段（渲染dom）</span></span>
<span class="line"><span>beforeMount（onBeforeMount）</span></span>
<span class="line"><span>mounted （onMounted）</span></span>
<span class="line"><span>更新阶段</span></span>
<span class="line"><span>beforeUpdate （onBeforeUpdate）</span></span>
<span class="line"><span>updated （onUpdated）</span></span>
<span class="line"><span>销毁阶段</span></span>
<span class="line"><span>beforeDestory （onBeforeUnmount）</span></span>
<span class="line"><span>destroyed （onUnmounted）</span></span></code></pre></div><h2 id="父组件引入子组件-生命周期的执行顺序是" tabindex="-1">父组件引入子组件，生命周期的执行顺序是 <a class="header-anchor" href="#父组件引入子组件-生命周期的执行顺序是" aria-label="Permalink to &quot;父组件引入子组件，生命周期的执行顺序是&quot;">​</a></h2><p>创建阶段</p><table><thead><tr><th>父组件</th><th>子组件</th></tr></thead><tbody><tr><td>beforeCreate</td><td></td></tr><tr><td>created</td><td></td></tr><tr><td>beforeMount</td><td></td></tr><tr><td></td><td>beforeCreate</td></tr><tr><td></td><td>created</td></tr><tr><td></td><td>beforeMount</td></tr><tr><td>--</td><td>--</td></tr><tr><td></td><td>mounted</td></tr><tr><td>mounted</td><td></td></tr></tbody></table><p>更新阶段</p><table><thead><tr><th>父组件</th><th>子组件</th></tr></thead><tbody><tr><td>beforeUpdate</td><td></td></tr><tr><td></td><td>beforeUpdate</td></tr><tr><td></td><td>updated</td></tr><tr><td>updated</td><td></td></tr></tbody></table><p>销毁阶段</p><table><thead><tr><th>父组件</th><th>子组件</th></tr></thead><tbody><tr><td>beforeDestroy</td><td></td></tr><tr><td></td><td>beforeDestroy</td></tr><tr><td></td><td>destroyed</td></tr><tr><td>destroyed</td><td></td></tr></tbody></table><ul><li>发送请求放在哪个生命周期 <ul><li>官方没有明确规定，<code>created、 mounted</code>都可以，created可以使请求早发起几毫秒（渲染页面的时间），mounted中DOM元素已经挂载完成，做一些相关操作更加方便。根据页面渲染的先后顺序，和父子组件生命周期调整。</li></ul></li><li>keep-alive <ul><li>activated</li><li>deactivated</li></ul></li></ul><h2 id="组件传值方式" tabindex="-1">组件传值方式 <a class="header-anchor" href="#组件传值方式" aria-label="Permalink to &quot;组件传值方式&quot;">​</a></h2><ul><li>父传子 <ul><li>props: 单向传值、子组件不可修改</li><li>依赖注入（provide/inject） 数据不是响应式的</li></ul></li><li>子传父 <ul><li>$emit</li></ul></li><li>兄弟组件 <ul><li>共同的父组件传递数据</li><li>事件总线</li><li>vuex</li></ul></li><li>$parent、$child、$refs <ul><li>不建议修改数据，调用事件（vant就这么用）</li></ul></li></ul>`,12),O=v('<h2 id="v-show和v-if区别" tabindex="-1">v-show和v-if区别 <a class="header-anchor" href="#v-show和v-if区别" aria-label="Permalink to &quot;v-show和v-if区别&quot;">​</a></h2><h2 id="v-for-key作用" tabindex="-1">v-for key作用 <a class="header-anchor" href="#v-for-key作用" aria-label="Permalink to &quot;v-for key作用&quot;">​</a></h2><p><a href="https://juejin.cn/post/7069004247651581989" target="_blank" rel="noreferrer">参考文档1: 掘金</a><a href="https://developer.aliyun.com/article/1432915" target="_blank" rel="noreferrer">参考文档2：阿里云</a></p><ol><li>准确性：在某些情况下，如果没有明确提供 :key，Vue 可能无法准确地跟踪和管理元素的身份。这可能导致意外的行为或渲染错误。</li><li>动态组件：如果你在 v-for 循环中动态地创建或切换组件，那么 :key 是必需的。它用于确保组件的正确卸载和重新加载。</li><li>可复用性：如果你打算在模板中复用相同的元素，并且它们在不同的循环中具有不同的状态，那么使用 :key 可以确保每个元素在其对应的循环中保持独立。</li></ol><p><strong>为什么要使用 key 呢？主要原因如下：</strong></p><p><strong>DOM Diff 算法：</strong> Vue 使用虚拟 DOM 来优化页面渲染。</p><p>key 主要用于 DOM Diff 算法，它在同级比较时，会比较当前标签上的 key 和标签名。如果 key 和标签名都一样，Vue 只会移动元素，而不会重新创建或删除元素。如果没有设置 key，默认会采用就地复用策略。这意味着，如果数据顺序发生变化，Vue 不会移动 DOM 元素来匹配数据项的改变，而是简单地复用原来位置的每个元素。这可能导致不必要的更新，而设置了 key 可以避免这个问题。</p><p><strong>避免使用索引值作为 key</strong>：尽量避免使用索引值（如 index）作为 key，因为当向数组中插入新元素时，索引会重新更新，导致不必要的更新。使用唯一标识（如 id）作为 key 更为合适，因为它不会受到数组顺序变化的影响。</p><p><strong>总之</strong>，为了更高效地更新虚拟 DOM，Vue 中的列表循环需要加上 :key=&#39;唯一标识&#39;，唯一标识最好是具有唯一性的值，如 id。这样可以确保在数据变化时，只更新需要更新的元素，而不会重新渲染整个列表。</p><h2 id="v-for和v-if优先级-如何一起使用" tabindex="-1">v-for和v-if优先级，如何一起使用 <a class="header-anchor" href="#v-for和v-if优先级-如何一起使用" aria-label="Permalink to &quot;v-for和v-if优先级，如何一起使用&quot;">​</a></h2><p>vue2中 v-for优先级更高，一起使用会造成性能浪费。</p><p>vue3中，v-if优先级更高，一起使用会不渲染。</p><p><strong>最优解</strong> 使用filter过滤数据</p><h2 id="watch和created执行顺序" tabindex="-1">watch和created执行顺序 <a class="header-anchor" href="#watch和created执行顺序" aria-label="Permalink to &quot;watch和created执行顺序&quot;">​</a></h2><p>vue2中 watch先执行</p><p>vue3中 watch后执行</p><h2 id="跨页面传参" tabindex="-1">跨页面传参 <a class="header-anchor" href="#跨页面传参" aria-label="Permalink to &quot;跨页面传参&quot;">​</a></h2><ol><li>路由传参 <ol><li>URL传参 (query)</li><li>router传参 (动态路由params, 需要预设)</li></ol></li></ol>',18);function A(o,t,s,f,a,n){const r=i("lifeCycle"),d=i("watchC"),b=i("instruct");return u(),h("div",null,[p(r),p(d),I,p(b),O])}const R=c(T,[["render",A]]);export{E as __pageData,R as default};
